options { 
    DEBUG_PARSER=false; 
    STATIC=false; 
} 
 
PARSER_BEGIN(Reader) 
package  src.pla  ;

import java.io.*;
 
public Competence Symb_to_Comp(String s) {
  switch(s){
    case "H":
    	return Hit;
    case "S":
    	return Soin;
    case "K":
    	return Kamikaze;
    case "A":
    	return AutoDestruction;
    case "V":
    	return Volvie;
    case "St":
    	return Stun;
    case "Ad":
    	return AugDef;
    case "D":
    	return DimDef;
    case "C":
    	return Contrer;
    case "P":
    	return Poison;
    case "B":
    	return Boost;
    case "Mr":
    	return MoveRamasse;
    case "Ma":
    	return MoveAttack;
    case "Md":
    	return MoveDef;
    default:
        return MoveRamasse;
 }
 
public class Reader { 
  /** le support de lecture */
  public static void main(String args []){
   		System.out.println("Entrez votre commande robot :");
 	    System.out.println(read().readArbre());
  }
  protected static java.io.Reader in = new BufferedReader(new InputStreamReader(System.in)); 
  /** lecture d'une S-EXPR au terminal 
   * @return Sexpr : la Sexpr construite. 
   * @throws LispException une erreur de syntaxe 
   */ 
  public static Noeud read() throws LispException{
	  	Reader parser = new Reader(in);
	  	Noeud n = null;
	  	try
 	    {
 	      n = parser.BASE();
 	    }
		catch (ParseException e)
		{
		  System.out.println(e.getMessage());
		}
	  	return n;
    }
    
  /** lecture d'une S-EXPR ï¿½ partir de la chaï¿½ne 
   * @param s : la chaï¿½ne 
   * @return Sexpr : la Sexpr construite. 
   * @throws LispException une  erreur de syntaxe 
   */ 
  public static Noeud read(String s) throws LispException{
    Reader parser = new Reader (in);
	Noeud n2 = null;
	try
	{
	  n2 = parser.BASE();
    }
    catch(ParseException e)
    {
      System.out.println(e.getMessage());
	}
	return n2;
   }
} 
 
PARSER_END(Reader) 

TOKEN :{ 
  < PARO : "(" >
| < PARF : ")" >
| < ACCO : "{" >
| < ACCF : " }" >
| < ITERE : ":" >
| < REPETE : "*" >
| < PTV : ";" >
| < HASARD  : "|" >
| < OU  : "||" >
| < INF  : "<" >
| < SUP  : " >" >
| <SYMBOL: (["a"-"z"]|["A"-"Z"])+ > 
}

// les règles de grammaire de ce langage

Noeud BASE() : 
{Noeud n1;} 
{ 
  (n1=EXPR(){return n1;})*
}

Noeud EXPR() :
{Noeud n2;}
{
	n2= < SYMBOL > {return Symb_to_Comp(n2.toString());}
	|<PARO> n2=LISTE() <PARF> {return n2;}
	|<ACCO> n2=LISTE() <ACCF> {return n2;}
	|<ACCO> n2=LISTE() <ACCF> <REPETE> {
	  Noeud n;
	  n.action=Etoile;
	  n.addFilsD(n2);
	  return n;}
	|<PARO> n2=LISTE() <PARF> <REPETE> {
	  Noeud n;
	  n.action=Etoile;
	  n.addFilsD(n2);
	  return n;}
}
}

Noeud LISTE() :
{Noeud n2,n3;}
{
	| n2= < SYMBOL > <PTV> n3=LISTE() {
	  Noeud n;
	  n.action = Symb_to_Comp(n2.toString());
	  n.addFilsD(n3);
	  return n;}

	| n2= LISTE() <OU> n3=LISTE() {
	  Noeud n;
	  n.action = Ou;
	  n.addFilsG(n2);
	  n.addFilsD(n3);
	  return n;}
	| n2= LISTE() <SUP> n3=LISTE() {
	  Noeud n;
	  n.action = Sup;
	  n.addFilsG(n2);
	  n.addFilsD(n3);
	  return n;}
}
